<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="text" encoding="UTF-8" />
  <xsl:strip-space elements="*" />

  <!-- Pulls sourceFileName from xsltproc command -->
  <xsl:param name="sourceFileName">unknown.xml</xsl:param>

  <!-- Get current path, used to generate correct md links -->
  <xsl:variable name="currentDir">
    <xsl:choose>
      <xsl:when test="contains($sourceFileName, '/')">
        <xsl:value-of
          select="substring-before($sourceFileName, concat('/', substring-after($sourceFileName, '/')))"
        />
      </xsl:when>
      <xsl:otherwise>.</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Root module template -->
  <xsl:template match="/module">
    <xsl:variable name="rawTitle" select="@name" />
    <xsl:variable name="cleanTitle">
      <xsl:choose>
        <xsl:when test="starts-with($rawTitle, 'Module ')">
          <xsl:value-of select="substring-after($rawTitle, 'Module ')" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$rawTitle" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- Assumes `module` means entire module is Plus only -->
    <xsl:variable
      name="moduleIsCommercial"
      select="
        boolean(.//commercial_version[
            text()='commercial subscription'
            and contains(../text(), 'available as part of our')
            and contains(../text(), 'This module is')
            and not(contains(../text(), 'Before version'))
            and not(contains(../text(), 'previously'))
        ])
    "
    />

    <!-- Assumes everything else is Plus but not for the entire module, hence, partial -->
    <xsl:variable
      name="partialCommercial"
      select="
        boolean(.//commercial_version[
            text()='commercial subscription'
            and contains(../text(), 'available as part of our')
            and not(contains(../text(), 'This module is'))
            and not(contains(../text(), 'Before version'))
            and not(contains(../text(), 'previously'))
        ])
    "
    />

    <!-- Hugo frontmatter -->

    <xsl:choose>
      <xsl:when test="$sourceFileName='http/ngx_http_api_module.xml'">
        <xsl:text>---&#10;</xsl:text>
        <xsl:text>title: </xsl:text>
        <xsl:value-of select="$cleanTitle" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>description: </xsl:text>
        <xsl:value-of select="$cleanTitle" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>toc: true&#10;</xsl:text>

        <xsl:if test="$sourceFileName='http/ngx_http_api_module.xml'">
            <xsl:text>nd-api-reference: &quot;./api/nginx_api.yaml&quot;</xsl:text>
            <xsl:text>&#10;</xsl:text>
        </xsl:if>

        <xsl:text>nd-org-source: </xsl:text>
        <xsl:value-of select="$sourceFileName" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>nd-commercial: </xsl:text>
        <xsl:choose>
          <xsl:when test="$moduleIsCommercial">true</xsl:when>
          <xsl:otherwise>false</xsl:otherwise>
        </xsl:choose>
        <xsl:text>&#10;</xsl:text>

        <xsl:text>nd-commercial-partial: </xsl:text>
        <xsl:choose>
          <xsl:when test="not($moduleIsCommercial) and $partialCommercial"
            >true</xsl:when
          >
          <xsl:otherwise>false</xsl:otherwise>
        </xsl:choose>
        <xsl:text>&#10;</xsl:text>

        <xsl:text>tags:&#10; - api&#10;</xsl:text>
        <xsl:text>doctypes:&#10; - reference&#10;</xsl:text>

        <xsl:text>---</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>---&#10;</xsl:text>

        <xsl:text>title: </xsl:text>
        <xsl:value-of select="$cleanTitle" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>description: </xsl:text>
        <xsl:value-of select="$cleanTitle" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>toc: true&#10;</xsl:text>

        <xsl:text>nd-org-source: </xsl:text>
        <xsl:value-of select="$sourceFileName" />
        <xsl:text>&#10;</xsl:text>

        <xsl:text>nd-commercial: </xsl:text>
        <xsl:choose>
          <xsl:when test="$moduleIsCommercial">true</xsl:when>
          <xsl:otherwise>false</xsl:otherwise>
        </xsl:choose>
        <xsl:text>&#10;</xsl:text>

        <xsl:text>nd-commercial-partial: </xsl:text>
        <xsl:choose>
          <xsl:when test="not($moduleIsCommercial) and $partialCommercial"
            >true</xsl:when
          >
          <xsl:otherwise>false</xsl:otherwise>
        </xsl:choose>
        <xsl:text>&#10;</xsl:text>

        <xsl:text>---&#10;&#10;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>

    <!-- Autogenerated warning comment -->
    <xsl:text
      >&#10;&lt;!--
      ********************************************************************************
      ðŸ›‘ WARNING: AUTOGENERATED FILE - DO NOT EDIT ðŸ›‘ This Markdown file was
      automatically generated from the source XML documentation. Any manual
      changes made directly to this file will be overwritten. To request or
      suggest changes, please edit the source XML files instead.
      https://github.com/nginx/nginx.org/tree/main/xml/en
      ********************************************************************************
      --&gt;&#10;&#10;</xsl:text
    >

    <xsl:apply-templates />
  </xsl:template>

  <!-- External link handling -->
  <xsl:template match="link[@url]">
    <xsl:text>[</xsl:text>
    <xsl:apply-templates />
    <xsl:text>](</xsl:text>
    <xsl:value-of select="@url" />
    <xsl:text>)</xsl:text>
  </xsl:template>

  <xsl:template match="literal|value|var|header">
    <xsl:text>`</xsl:text><xsl:value-of select="normalize-space(.)" /><xsl:text
      >`</xsl:text
    >
  </xsl:template>

  <!-- ignore emphasis in code blocks, we can't support it -->
  <xsl:template match="emphasis[not(ancestor::example)]">
    <xsl:text>*</xsl:text>
    <xsl:apply-templates />
    <xsl:text>*</xsl:text>
  </xsl:template>

  <xsl:template match="emphasis[ancestor::example]">
    <xsl:apply-templates />
  </xsl:template>

  <xsl:template match="link">
    <xsl:text>[</xsl:text><xsl:apply-templates /><xsl:text>](</xsl:text>
    <xsl:value-of select="@doc" />
    <xsl:if test="@id">#<xsl:value-of select="@id" /></xsl:if>
    <xsl:text>)</xsl:text>
  </xsl:template>

  <xsl:template match="link[@doc]">
    <xsl:variable name="markdownPath">
      <xsl:text>/nginx/module-reference/</xsl:text>
      <xsl:choose>
        <xsl:when test="contains(@doc, '/')">
          <!-- explicit path, leave as-is (removing .xml extension) -->
          <xsl:value-of select="substring-before(@doc, '.xml')" />
        </xsl:when>
        <xsl:otherwise>
          <!-- just filename.xml: prepend current directory if needed -->
          <xsl:if test="$currentDir != '.'">
            <xsl:value-of select="$currentDir" />
            <xsl:text>/</xsl:text>
          </xsl:if>
          <xsl:value-of select="substring-before(@doc, '.xml')" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- output markdown link explicitly -->
    <xsl:text>[</xsl:text>
    <!-- if the node contains text, render that -->
    <xsl:choose>
      <xsl:when test="count(node()) != 0">
        <xsl:apply-templates />
      </xsl:when>
      <!-- otherwise fallback to id or filename -->
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="@id">
            <xsl:value-of select="@id" />
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="substring-before(@doc, '.xml')" />
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>](</xsl:text>
    <xsl:value-of select="$markdownPath" />
    <xsl:if test="@id">
      <xsl:text>#</xsl:text>
      <xsl:value-of select="@id" />
    </xsl:if>
    <xsl:text>)</xsl:text>
  </xsl:template>

  <xsl:template match="list[@type='bullet']">
    <xsl:text>&#10;</xsl:text>
    <!-- spacing before list -->
    <xsl:apply-templates select="listitem" />
    <xsl:text>&#10;</xsl:text>
    <!-- spacing after list -->
  </xsl:template>

  <xsl:template match="listitem">
    <!-- output the dash -->
    <xsl:text>- </xsl:text>

    <!-- Normalize item content spaces/line breaks explicitly -->
    <xsl:call-template name="normalize-inline-content">
      <xsl:with-param name="nodes" select="node()" />
    </xsl:call-template>

    <xsl:text>&#10;</xsl:text>
    <!-- newline after item -->
  </xsl:template>

  <!-- This additional template explicitly normalizes inline content (text / links) -->
  <xsl:template name="normalize-inline-content">
    <xsl:param name="nodes" />
    <xsl:for-each select="$nodes">
      <xsl:choose>
        <xsl:when test="self::text()">
          <!-- normalize any whitespace in text nodes -->
          <xsl:value-of select="normalize-space(.)" />
        </xsl:when>

        <xsl:otherwise>
          <!-- Apply templates recursively (handles <link>, other nodes correctly) -->
          <xsl:apply-templates select="." />
        </xsl:otherwise>
      </xsl:choose>

      <!-- add space if not last node and next is not punctuation -->
      <xsl:if test="position()!=last()">
        <xsl:text> </xsl:text>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <!-- Sections -->
  <xsl:template match="section[@name]">
    <xsl:text>## </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:text>&#10;&#10;</xsl:text>
    <xsl:apply-templates />
  </xsl:template>

  <!-- Directives -->
  <xsl:template match="directive">
    <!-- Directive Markdown heading -->
    <xsl:text>### </xsl:text>
    <xsl:value-of select="@name" />
    <xsl:variable
      name="directiveIsCommercial"
      select="boolean(.//commercial_version[
            text()='commercial subscription'
            and contains(../text(), 'available as part of our')
            and (contains(../text(), 'This directive is')
                or contains(../text(), 'The parameter is')
                or contains(../text(), 'This functionality is'))
            and not(contains(../text(), 'Before version'))
            and not(contains(../text(), 'previously'))
        ])"
    />
    <xsl:if test="$directiveIsCommercial"> âœ©</xsl:if>
    <xsl:text>&#10;&#10;</xsl:text>

    <!-- Syntax -->
    <xsl:for-each select="syntax">
      <xsl:text>**Syntax:** </xsl:text>
      <xsl:value-of select="../@name" />
      <xsl:text> </xsl:text>
      <xsl:call-template name="inline-block" />
      <xsl:text>&#10;&#10;</xsl:text>
    </xsl:for-each>

    <!-- Default -->
    <xsl:text>**Default:** </xsl:text>
    <xsl:choose>
      <xsl:when test="normalize-space(default)">
        <xsl:value-of select="normalize-space(default)" />
      </xsl:when>
      <xsl:otherwise>-</xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#10;&#10;</xsl:text>

    <!-- Context -->
    <xsl:if test="context">
      <xsl:text>**Context:** </xsl:text>
      <xsl:for-each select="context">
        <xsl:value-of select="normalize-space(.)" />
        <xsl:if test="position()!=last()">, </xsl:if>
      </xsl:for-each>
      <xsl:text>&#10;&#10;</xsl:text>
    </xsl:if>

    <!-- Appeared-in -->
    <xsl:if test="appeared-in">
      <xsl:text>_This directive appeared in version </xsl:text>
      <xsl:value-of select="normalize-space(appeared-in)" />
      <xsl:text>._&#10;&#10;</xsl:text>
    </xsl:if>

    <!-- The para (description) content -->
    <xsl:apply-templates select="para" />
  </xsl:template>

  <!-- Example to md codeblock, assumes nginx content type -->
  <xsl:template match="example">
    <xsl:text>&#10;```nginx &#10;</xsl:text>
    <!-- Avoid extra blank lines: trim any leading newline -->
    <xsl:variable name="trimmed">
      <xsl:choose>
        <xsl:when test="starts-with(string(.), '&#10;')">
          <xsl:value-of select="substring-after(string(.), '&#10;')" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="string(.)" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:value-of select="$trimmed" />
    <xsl:text> ```&#10;&#10;</xsl:text>
  </xsl:template>

  <!-- Inline-block template explicitly -->
  <xsl:template name="inline-block">
    <xsl:for-each select="node()">
      <xsl:choose>
        <xsl:when test="self::value|self::literal|self::var|self::header">
          <xsl:text>`</xsl:text
          ><xsl:value-of select="normalize-space(.)" /><xsl:text>`</xsl:text>
        </xsl:when>
        <xsl:when test="self::text()">
          <xsl:value-of select="normalize-space(.)" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="." />
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="position()!=last()"><xsl:text> </xsl:text></xsl:if>
    </xsl:for-each>
  </xsl:template>

  <!-- c-func template -->
  <xsl:template match="c-func">
    <xsl:text>`</xsl:text>
    <xsl:value-of select="normalize-space(.)" />
    <xsl:text>()`</xsl:text>
  </xsl:template>

  <!-- command template -->
  <xsl:template match="command">
    <xsl:text>`</xsl:text>
    <xsl:value-of select="normalize-space(.)" />
    <xsl:text>`</xsl:text>
  </xsl:template>

  <!-- note -->
  <xsl:template match="note">
    <xsl:text>&#10;&gt; </xsl:text>
    <xsl:call-template name="normalize-inline-content">
      <xsl:with-param name="nodes" select="node()" />
    </xsl:call-template>
    <xsl:text>&#10;&#10;</xsl:text>
  </xsl:template>

  <!-- Embedded variables handling -->
  <xsl:template match="list[@type='tag']">
    <xsl:text>&#10;</xsl:text>
    <xsl:apply-templates select="tag-name | tag-desc" />
    <xsl:text>&#10;</xsl:text>
  </xsl:template>

  <xsl:template match="tag-name[@id='var_cookie_']">
    <xsl:text>&#10;### `$cookie_&lt;name&gt;`&#10;&#10;</xsl:text>
  </xsl:template>

  <xsl:template match="tag-name">
    <xsl:text>&#10;### </xsl:text>
    <xsl:choose>
      <!-- base+placeholder pattern -->
      <xsl:when test="var and value">
        <xsl:text>`</xsl:text>
        <xsl:value-of select="var" />
        <xsl:text>&lt;</xsl:text>
        <xsl:value-of select="value" />
        <xsl:text>&gt;`</xsl:text>
      </xsl:when>
      <!-- multiple <var> pattern (allow text like commas) -->
      <xsl:when test="count(var) &gt; 1">
        <xsl:for-each select="node()">
          <xsl:choose>
            <xsl:when test="self::var">
              <xsl:text>`</xsl:text><xsl:value-of select="." /><xsl:text
                >`</xsl:text
              >
            </xsl:when>
            <xsl:when test="self::text()">
              <xsl:value-of select="." />
            </xsl:when>
          </xsl:choose>
        </xsl:for-each>
      </xsl:when>
      <!-- fallback, just in case -->
      <xsl:otherwise>
        <xsl:for-each select="node()">
          <xsl:choose>
            <xsl:when test="self::literal or self::value or self::var">
              <xsl:text>`</xsl:text><xsl:value-of select="." /><xsl:text
                >`</xsl:text
              >
            </xsl:when>
            <xsl:when test="self::text()">
              <xsl:value-of select="." />
            </xsl:when>
          </xsl:choose>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#10;&#10;</xsl:text>
  </xsl:template>

  <xsl:template match="tag-desc">
    <xsl:apply-templates />
    <xsl:text>&#10;&#10;</xsl:text>
  </xsl:template>
</xsl:stylesheet>
